import { describe, it, expect, beforeEach, vi } from 'vitest'

/**
 * Firebase-compatible JWT Generation Tests
 *
 * These tests verify that JWT tokens generated by firebase.do match the exact
 * format used by Firebase Authentication. Firebase ID tokens are RS256-signed
 * JWTs with a specific structure that clients and backend services depend on.
 *
 * Reference: https://firebase.google.com/docs/auth/admin/verify-id-tokens
 */

// Placeholder for the actual JWT generation implementation
// This will be imported from the auth module once implemented
interface FirebaseJwtPayload {
  iss: string
  aud: string
  sub: string
  user_id: string
  auth_time: number
  iat: number
  exp: number
  email?: string
  email_verified?: boolean
  phone_number?: string
  name?: string
  picture?: string
  firebase: {
    identities: Record<string, string[]>
    sign_in_provider: string
  }
  [key: string]: unknown // For custom claims
}

interface FirebaseJwtHeader {
  alg: string
  typ: string
  kid: string
}

interface GenerateTokenOptions {
  uid: string
  projectId: string
  claims?: Record<string, unknown>
  signInProvider?: string
  identities?: Record<string, string[]>
  email?: string
  emailVerified?: boolean
}

// Import from actual implementation
import { generateFirebaseToken, rotateSigningKey } from '../../src/auth/jwt'

const decodeJwt = (token: string): { header: FirebaseJwtHeader; payload: FirebaseJwtPayload } => {
  const parts = token.split('.')
  if (parts.length !== 3) {
    throw new Error('Invalid JWT format: expected 3 parts')
  }

  const header = JSON.parse(Buffer.from(parts[0], 'base64url').toString('utf-8'))
  const payload = JSON.parse(Buffer.from(parts[1], 'base64url').toString('utf-8'))

  return { header, payload }
}

describe('Firebase-compatible JWT Generation', () => {
  const projectId = 'test-project-id'
  const uid = 'user-123-abc'

  describe('JWT Header Structure', () => {
    it('should use RS256 algorithm', async () => {
      const token = await generateFirebaseToken({ uid, projectId })
      const { header } = decodeJwt(token)

      expect(header.alg).toBe('RS256')
    })

    it('should have typ set to JWT', async () => {
      const token = await generateFirebaseToken({ uid, projectId })
      const { header } = decodeJwt(token)

      expect(header.typ).toBe('JWT')
    })

    it('should include kid (key ID) in header', async () => {
      const token = await generateFirebaseToken({ uid, projectId })
      const { header } = decodeJwt(token)

      expect(header.kid).toBeDefined()
      expect(typeof header.kid).toBe('string')
      expect(header.kid.length).toBeGreaterThan(0)
    })
  })

  describe('JWT Payload - Required Claims', () => {
    it('should set iss (issuer) to Firebase securetoken URL with project ID', async () => {
      const token = await generateFirebaseToken({ uid, projectId })
      const { payload } = decodeJwt(token)

      expect(payload.iss).toBe(`https://securetoken.google.com/${projectId}`)
    })

    it('should set aud (audience) to project ID', async () => {
      const token = await generateFirebaseToken({ uid, projectId })
      const { payload } = decodeJwt(token)

      expect(payload.aud).toBe(projectId)
    })

    it('should set sub (subject) to the user ID', async () => {
      const token = await generateFirebaseToken({ uid, projectId })
      const { payload } = decodeJwt(token)

      expect(payload.sub).toBe(uid)
    })

    it('should include user_id matching sub', async () => {
      const token = await generateFirebaseToken({ uid, projectId })
      const { payload } = decodeJwt(token)

      expect(payload.user_id).toBe(uid)
      expect(payload.user_id).toBe(payload.sub)
    })

    it('should include auth_time as Unix timestamp', async () => {
      const beforeTime = Math.floor(Date.now() / 1000)
      const token = await generateFirebaseToken({ uid, projectId })
      const afterTime = Math.floor(Date.now() / 1000)
      const { payload } = decodeJwt(token)

      expect(payload.auth_time).toBeGreaterThanOrEqual(beforeTime)
      expect(payload.auth_time).toBeLessThanOrEqual(afterTime)
      expect(Number.isInteger(payload.auth_time)).toBe(true)
    })

    it('should include iat (issued at) as Unix timestamp', async () => {
      const beforeTime = Math.floor(Date.now() / 1000)
      const token = await generateFirebaseToken({ uid, projectId })
      const afterTime = Math.floor(Date.now() / 1000)
      const { payload } = decodeJwt(token)

      expect(payload.iat).toBeGreaterThanOrEqual(beforeTime)
      expect(payload.iat).toBeLessThanOrEqual(afterTime)
      expect(Number.isInteger(payload.iat)).toBe(true)
    })

    it('should include exp (expiration) as Unix timestamp', async () => {
      const token = await generateFirebaseToken({ uid, projectId })
      const { payload } = decodeJwt(token)

      expect(payload.exp).toBeDefined()
      expect(Number.isInteger(payload.exp)).toBe(true)
      expect(payload.exp).toBeGreaterThan(payload.iat)
    })
  })

  describe('JWT Payload - Token Expiration', () => {
    it('should expire exactly 1 hour (3600 seconds) after issuance', async () => {
      const token = await generateFirebaseToken({ uid, projectId })
      const { payload } = decodeJwt(token)

      const expirationDuration = payload.exp - payload.iat
      expect(expirationDuration).toBe(3600)
    })

    it('should have exp greater than current time', async () => {
      const token = await generateFirebaseToken({ uid, projectId })
      const { payload } = decodeJwt(token)
      const now = Math.floor(Date.now() / 1000)

      expect(payload.exp).toBeGreaterThan(now)
    })

    it('should have consistent timing between auth_time and iat', async () => {
      const token = await generateFirebaseToken({ uid, projectId })
      const { payload } = decodeJwt(token)

      // auth_time should be <= iat (auth happened before or at token issuance)
      expect(payload.auth_time).toBeLessThanOrEqual(payload.iat)
    })
  })

  describe('JWT Payload - Firebase Claim', () => {
    it('should include firebase claim object', async () => {
      const token = await generateFirebaseToken({ uid, projectId })
      const { payload } = decodeJwt(token)

      expect(payload.firebase).toBeDefined()
      expect(typeof payload.firebase).toBe('object')
    })

    it('should include identities in firebase claim', async () => {
      const token = await generateFirebaseToken({ uid, projectId })
      const { payload } = decodeJwt(token)

      expect(payload.firebase.identities).toBeDefined()
      expect(typeof payload.firebase.identities).toBe('object')
    })

    it('should include sign_in_provider in firebase claim', async () => {
      const token = await generateFirebaseToken({ uid, projectId })
      const { payload } = decodeJwt(token)

      expect(payload.firebase.sign_in_provider).toBeDefined()
      expect(typeof payload.firebase.sign_in_provider).toBe('string')
    })

    it('should default sign_in_provider to "custom" for custom auth', async () => {
      const token = await generateFirebaseToken({ uid, projectId })
      const { payload } = decodeJwt(token)

      expect(payload.firebase.sign_in_provider).toBe('custom')
    })

    it('should use specified sign_in_provider when provided', async () => {
      const token = await generateFirebaseToken({
        uid,
        projectId,
        signInProvider: 'google.com'
      })
      const { payload } = decodeJwt(token)

      expect(payload.firebase.sign_in_provider).toBe('google.com')
    })

    it('should include email identity for email/password auth', async () => {
      const email = 'user@example.com'
      const token = await generateFirebaseToken({
        uid,
        projectId,
        email,
        signInProvider: 'password',
        identities: { email: [email] }
      })
      const { payload } = decodeJwt(token)

      expect(payload.firebase.identities.email).toContain(email)
      expect(payload.firebase.sign_in_provider).toBe('password')
    })

    it('should include Google identity for Google sign-in', async () => {
      const googleId = '123456789'
      const token = await generateFirebaseToken({
        uid,
        projectId,
        signInProvider: 'google.com',
        identities: { 'google.com': [googleId] }
      })
      const { payload } = decodeJwt(token)

      expect(payload.firebase.identities['google.com']).toContain(googleId)
      expect(payload.firebase.sign_in_provider).toBe('google.com')
    })
  })

  describe('Custom Claims', () => {
    it('should include custom claims in payload', async () => {
      const customClaims = {
        role: 'admin',
        permissions: ['read', 'write', 'delete']
      }

      const token = await generateFirebaseToken({
        uid,
        projectId,
        claims: customClaims
      })
      const { payload } = decodeJwt(token)

      expect(payload.role).toBe('admin')
      expect(payload.permissions).toEqual(['read', 'write', 'delete'])
    })

    it('should not allow custom claims to override reserved claims', async () => {
      const maliciousClaims = {
        sub: 'hacked-user',
        iss: 'https://evil.com',
        aud: 'wrong-project',
        exp: 9999999999,
        iat: 0,
        auth_time: 0,
        user_id: 'hacked',
        firebase: { sign_in_provider: 'hacked' }
      }

      const token = await generateFirebaseToken({
        uid,
        projectId,
        claims: maliciousClaims
      })
      const { payload } = decodeJwt(token)

      // Reserved claims should not be overridden
      expect(payload.sub).toBe(uid)
      expect(payload.user_id).toBe(uid)
      expect(payload.iss).toBe(`https://securetoken.google.com/${projectId}`)
      expect(payload.aud).toBe(projectId)
      expect(payload.firebase.sign_in_provider).not.toBe('hacked')
    })

    it('should support nested custom claims', async () => {
      const customClaims = {
        organization: {
          id: 'org-123',
          name: 'Acme Corp',
          roles: ['member', 'billing']
        }
      }

      const token = await generateFirebaseToken({
        uid,
        projectId,
        claims: customClaims
      })
      const { payload } = decodeJwt(token)

      expect(payload.organization).toEqual(customClaims.organization)
    })

    it('should handle empty custom claims gracefully', async () => {
      const token = await generateFirebaseToken({
        uid,
        projectId,
        claims: {}
      })
      const { payload } = decodeJwt(token)

      // Should still have all required fields
      expect(payload.sub).toBe(uid)
      expect(payload.firebase).toBeDefined()
    })
  })

  describe('Key Rotation', () => {
    it('should include kid in header for key identification', async () => {
      const token = await generateFirebaseToken({ uid, projectId })
      const { header } = decodeJwt(token)

      expect(header.kid).toBeDefined()
      expect(typeof header.kid).toBe('string')
    })

    it('should use new kid after key rotation', async () => {
      const token1 = await generateFirebaseToken({ uid, projectId })
      const { header: header1 } = decodeJwt(token1)

      // Rotate the signing key
      const { kid: newKid } = await rotateSigningKey()

      const token2 = await generateFirebaseToken({ uid, projectId })
      const { header: header2 } = decodeJwt(token2)

      expect(header2.kid).toBe(newKid)
      expect(header2.kid).not.toBe(header1.kid)
    })

    it('should generate unique key IDs on rotation', async () => {
      const keyIds = new Set<string>()

      for (let i = 0; i < 5; i++) {
        const { kid } = await rotateSigningKey()
        expect(keyIds.has(kid)).toBe(false)
        keyIds.add(kid)
      }

      expect(keyIds.size).toBe(5)
    })
  })

  describe('JWT Format Validation', () => {
    it('should produce a valid JWT with three base64url-encoded parts', async () => {
      const token = await generateFirebaseToken({ uid, projectId })

      const parts = token.split('.')
      expect(parts.length).toBe(3)

      // Verify each part is valid base64url
      const base64urlRegex = /^[A-Za-z0-9_-]+$/
      parts.forEach((part, index) => {
        expect(part).toMatch(base64urlRegex)
      })
    })

    it('should produce decodable header and payload', async () => {
      const token = await generateFirebaseToken({ uid, projectId })

      expect(() => decodeJwt(token)).not.toThrow()

      const { header, payload } = decodeJwt(token)
      expect(header).toBeDefined()
      expect(payload).toBeDefined()
    })

    it('should include signature as third part', async () => {
      const token = await generateFirebaseToken({ uid, projectId })
      const parts = token.split('.')

      // Signature should be present and non-empty
      expect(parts[2]).toBeDefined()
      expect(parts[2].length).toBeGreaterThan(0)
    })
  })

  describe('Edge Cases', () => {
    it('should handle special characters in uid', async () => {
      const specialUid = 'user:123+test@special'
      const token = await generateFirebaseToken({ uid: specialUid, projectId })
      const { payload } = decodeJwt(token)

      expect(payload.sub).toBe(specialUid)
      expect(payload.user_id).toBe(specialUid)
    })

    it('should handle very long uid', async () => {
      const longUid = 'a'.repeat(128)
      const token = await generateFirebaseToken({ uid: longUid, projectId })
      const { payload } = decodeJwt(token)

      expect(payload.sub).toBe(longUid)
    })

    it('should handle project ID with hyphens', async () => {
      const hyphenatedProjectId = 'my-test-project-123'
      const token = await generateFirebaseToken({ uid, projectId: hyphenatedProjectId })
      const { payload } = decodeJwt(token)

      expect(payload.aud).toBe(hyphenatedProjectId)
      expect(payload.iss).toBe(`https://securetoken.google.com/${hyphenatedProjectId}`)
    })

    it('should reject empty uid', async () => {
      await expect(
        generateFirebaseToken({ uid: '', projectId })
      ).rejects.toThrow()
    })

    it('should reject empty projectId', async () => {
      await expect(
        generateFirebaseToken({ uid, projectId: '' })
      ).rejects.toThrow()
    })
  })
})
